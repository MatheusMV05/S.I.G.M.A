<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/sigma/src/main/java/com/project/sigma/controller/ProdutoController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sigma/src/main/java/com/project/sigma/controller/ProdutoController.java" />
              <option name="originalContent" value="package com.project.sigma.controller;&#10;&#10;import com.project.sigma.dto.PaginatedResponseDTO;&#10;import com.project.sigma.dto.ProdutoRequestDTO;&#10;import com.project.sigma.dto.ProdutoResponseDTO;&#10;import com.project.sigma.model.Produto;&#10;import com.project.sigma.service.ProdutoService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/products&quot;)&#10;public class ProdutoController {&#10;&#10;    @Autowired&#10;    private ProdutoService produtoService;&#10;&#10;    @GetMapping&#10;    public PaginatedResponseDTO&lt;ProdutoResponseDTO&gt; listarProdutos(&#10;        @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;        @RequestParam(defaultValue = &quot;10&quot;) int size,&#10;        @RequestParam(required = false) String search,&#10;        @RequestParam(required = false) Long categoryId,&#10;        @RequestParam(required = false) String status&#10;    ) {&#10;        System.out.println(&quot; GET /api/products - Listando produtos com paginação&quot;);&#10;        System.out.println(&quot;    Parâmetros: page=&quot; + page + &quot;, size=&quot; + size + &quot;, search=&quot; + search + &quot;, categoryId=&quot; + categoryId + &quot;, status=&quot; + status);&#10;&#10;        PaginatedResponseDTO&lt;ProdutoResponseDTO&gt; response = produtoService.buscarProdutosComPaginacao(page, size, search, categoryId, status);&#10;&#10;        System.out.println(&quot; Retornando resposta paginada&quot;);&#10;        return response;&#10;    }&#10;&#10;    @GetMapping(&quot;/low-stock&quot;)&#10;    public ResponseEntity&lt;?&gt; getLowStockProducts() {&#10;        System.out.println(&quot;⚠️ GET /api/products/low-stock - Buscando produtos com baixo estoque&quot;);&#10;&#10;        try {&#10;            return ResponseEntity.ok(produtoService.buscarProdutosComBaixoEstoque());&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;❌ Erro ao buscar produtos com baixo estoque: &quot; + e.getMessage());&#10;            return ResponseEntity.ok(new Object[0]);&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;ProdutoResponseDTO&gt; getProdutoById(@PathVariable Long id) {&#10;        return produtoService.buscarProdutoCompletoPorId(id)&#10;                .map(ResponseEntity::ok)&#10;                .orElse(ResponseEntity.notFound().build());&#10;    }&#10;&#10;    @PostMapping&#10;    public ResponseEntity&lt;Produto&gt; criarProduto(@RequestBody ProdutoRequestDTO dto) {&#10;        System.out.println(&quot;=== DEBUG PRODUTO CREATE ===&quot;);&#10;        System.out.println(&quot;DTO recebido do frontend para CRIAR:&quot;);&#10;&#10;        // Convert DTO to entity using new schema field names&#10;        Produto produto = new Produto();&#10;        produto.setNome(dto.getNome());&#10;        produto.setMarca(dto.getMarca());&#10;        produto.setEstoque(dto.getQuantEmEstoque());&#10;        produto.setPreco_venda(dto.getValorUnitario());&#10;        produto.setData_validade(dto.getDataValidade());&#10;        produto.setId_categoria(dto.getIdCategoria());&#10;        produto.setDescricao(dto.getDescricao());&#10;        produto.setEstoque_minimo(dto.getEstoqueMinimo());&#10;        // CORRIGIDO: garantir que estoque_maximo nunca seja null&#10;        produto.setEstoque_maximo(dto.getEstoqueMaximo() != null ? dto.getEstoqueMaximo() : 1000);&#10;        produto.setPreco_custo(dto.getPrecoCusto());&#10;        produto.setStatus(Produto.StatusProduto.valueOf(dto.getStatus()));&#10;        produto.setCodigo_barras(dto.getCodigoBarras());&#10;&#10;        System.out.println(&quot;Produto convertido antes de enviar para service:&quot;);&#10;        System.out.println(&quot;preco_venda: &quot; + produto.getPreco_venda());&#10;        System.out.println(&quot;estoque: &quot; + produto.getEstoque());&#10;        System.out.println(&quot;preco_custo: &quot; + produto.getPreco_custo());&#10;        System.out.println(&quot;status: &quot; + produto.getStatus());&#10;        System.out.println(&quot;estoque_maximo: &quot; + produto.getEstoque_maximo());&#10;        System.out.println(&quot;===============================&quot;);&#10;&#10;        Produto novoProduto = produtoService.criarProduto(produto);&#10;        System.out.println(&quot;✅ Produto criado com sucesso&quot;);&#10;        return new ResponseEntity&lt;&gt;(novoProduto, HttpStatus.CREATED);&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;Produto&gt; atualizarProduto(@PathVariable Long id, @RequestBody ProdutoRequestDTO dto) {&#10;        System.out.println(&quot;=== DEBUG PRODUTO UPDATE ===&quot;);&#10;        System.out.println(&quot;ID recebido: &quot; + id);&#10;&#10;        // Convert DTO to entity using new schema field names&#10;        Produto produto = new Produto();&#10;        produto.setId_produto(id);&#10;        produto.setNome(dto.getNome());&#10;        produto.setMarca(dto.getMarca());&#10;        produto.setEstoque(dto.getQuantEmEstoque());&#10;        produto.setPreco_venda(dto.getValorUnitario());&#10;        produto.setData_validade(dto.getDataValidade());&#10;        produto.setId_categoria(dto.getIdCategoria());&#10;        produto.setDescricao(dto.getDescricao());&#10;        produto.setEstoque_minimo(dto.getEstoqueMinimo());&#10;        // CORRIGIDO: garantir que estoque_maximo nunca seja null&#10;        produto.setEstoque_maximo(dto.getEstoqueMaximo() != null ? dto.getEstoqueMaximo() : 1000);&#10;        produto.setPreco_custo(dto.getPrecoCusto());&#10;        produto.setStatus(Produto.StatusProduto.valueOf(dto.getStatus()));&#10;        produto.setCodigo_barras(dto.getCodigoBarras());&#10;&#10;        System.out.println(&quot;Produto antes de enviar para service:&quot;);&#10;        System.out.println(&quot;preco_venda: &quot; + produto.getPreco_venda());&#10;        System.out.println(&quot;estoque: &quot; + produto.getEstoque());&#10;        System.out.println(&quot;estoque_maximo: &quot; + produto.getEstoque_maximo());&#10;        System.out.println(&quot;===============================&quot;);&#10;&#10;        Produto produtoAtualizado = produtoService.atualizarProduto(produto);&#10;        return ResponseEntity.ok(produtoAtualizado);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deletarProduto(@PathVariable Long id) {&#10;        produtoService.deletarProduto(id);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.project.sigma.controller;&#10;&#10;import com.project.sigma.dto.PaginatedResponseDTO;&#10;import com.project.sigma.dto.ProdutoRequestDTO;&#10;import com.project.sigma.dto.ProdutoResponseDTO;&#10;import com.project.sigma.model.Produto;&#10;import com.project.sigma.service.ProdutoService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/products&quot;)&#10;public class ProdutoController {&#10;&#10;    @Autowired&#10;    private ProdutoService produtoService;&#10;&#10;    @GetMapping&#10;    public PaginatedResponseDTO&lt;ProdutoResponseDTO&gt; listarProdutos(&#10;        @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;        @RequestParam(defaultValue = &quot;10&quot;) int size,&#10;        @RequestParam(required = false) String search,&#10;        @RequestParam(required = false) Long categoryId,&#10;        @RequestParam(required = false) Long categoriaId, // ADICIONADO: para compatibilidade com frontend&#10;        @RequestParam(required = false) String status&#10;    ) {&#10;        // CORRIGIDO: usar categoriaId se categoryId for null&#10;        Long finalCategoryId = categoryId != null ? categoryId : categoriaId;&#10;        &#10;        System.out.println(&quot; GET /api/products - Listando produtos com paginação&quot;);&#10;        System.out.println(&quot;    Parâmetros: page=&quot; + page + &quot;, size=&quot; + size + &quot;, search=&quot; + search + &quot;, categoryId=&quot; + categoryId + &quot;, categoriaId=&quot; + categoriaId + &quot;, finalCategoryId=&quot; + finalCategoryId + &quot;, status=&quot; + status);&#10;&#10;        PaginatedResponseDTO&lt;ProdutoResponseDTO&gt; response = produtoService.buscarProdutosComPaginacao(page, size, search, finalCategoryId, status);&#10;&#10;        System.out.println(&quot; Retornando resposta paginada&quot;);&#10;        return response;&#10;    }&#10;&#10;    @GetMapping(&quot;/low-stock&quot;)&#10;    public ResponseEntity&lt;?&gt; getLowStockProducts() {&#10;        System.out.println(&quot;⚠️ GET /api/products/low-stock - Buscando produtos com baixo estoque&quot;);&#10;&#10;        try {&#10;            return ResponseEntity.ok(produtoService.buscarProdutosComBaixoEstoque());&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;❌ Erro ao buscar produtos com baixo estoque: &quot; + e.getMessage());&#10;            return ResponseEntity.ok(new Object[0]);&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/{id:[0-9]+}&quot;)  // CORRIGIDO: especifica que id deve ser numérico&#10;    public ResponseEntity&lt;ProdutoResponseDTO&gt; getProdutoById(@PathVariable Long id) {&#10;        return produtoService.buscarProdutoCompletoPorId(id)&#10;                .map(ResponseEntity::ok)&#10;                .orElse(ResponseEntity.notFound().build());&#10;    }&#10;&#10;    @PostMapping&#10;    public ResponseEntity&lt;Produto&gt; criarProduto(@RequestBody ProdutoRequestDTO dto) {&#10;        System.out.println(&quot;=== DEBUG PRODUTO CREATE ===&quot;);&#10;        System.out.println(&quot;DTO recebido do frontend para CRIAR:&quot;);&#10;&#10;        // Convert DTO to entity using new schema field names&#10;        Produto produto = new Produto();&#10;        produto.setNome(dto.getNome());&#10;        produto.setMarca(dto.getMarca());&#10;        produto.setEstoque(dto.getQuantEmEstoque());&#10;        produto.setPreco_venda(dto.getValorUnitario());&#10;        produto.setData_validade(dto.getDataValidade());&#10;        produto.setId_categoria(dto.getIdCategoria());&#10;        produto.setDescricao(dto.getDescricao());&#10;        produto.setEstoque_minimo(dto.getEstoqueMinimo());&#10;        // CORRIGIDO: garantir que estoque_maximo nunca seja null&#10;        produto.setEstoque_maximo(dto.getEstoqueMaximo() != null ? dto.getEstoqueMaximo() : 1000);&#10;        produto.setPreco_custo(dto.getPrecoCusto());&#10;        produto.setStatus(Produto.StatusProduto.valueOf(dto.getStatus()));&#10;        produto.setCodigo_barras(dto.getCodigoBarras());&#10;&#10;        System.out.println(&quot;Produto convertido antes de enviar para service:&quot;);&#10;        System.out.println(&quot;preco_venda: &quot; + produto.getPreco_venda());&#10;        System.out.println(&quot;estoque: &quot; + produto.getEstoque());&#10;        System.out.println(&quot;preco_custo: &quot; + produto.getPreco_custo());&#10;        System.out.println(&quot;status: &quot; + produto.getStatus());&#10;        System.out.println(&quot;estoque_maximo: &quot; + produto.getEstoque_maximo());&#10;        System.out.println(&quot;===============================&quot;);&#10;&#10;        Produto novoProduto = produtoService.criarProduto(produto);&#10;        System.out.println(&quot;✅ Produto criado com sucesso&quot;);&#10;        return new ResponseEntity&lt;&gt;(novoProduto, HttpStatus.CREATED);&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;Produto&gt; atualizarProduto(@PathVariable Long id, @RequestBody ProdutoRequestDTO dto) {&#10;        System.out.println(&quot;=== DEBUG PRODUTO UPDATE ===&quot;);&#10;        System.out.println(&quot;ID recebido: &quot; + id);&#10;&#10;        // Convert DTO to entity using new schema field names&#10;        Produto produto = new Produto();&#10;        produto.setId_produto(id);&#10;        produto.setNome(dto.getNome());&#10;        produto.setMarca(dto.getMarca());&#10;        produto.setEstoque(dto.getQuantEmEstoque());&#10;        produto.setPreco_venda(dto.getValorUnitario());&#10;        produto.setData_validade(dto.getDataValidade());&#10;        produto.setId_categoria(dto.getIdCategoria());&#10;        produto.setDescricao(dto.getDescricao());&#10;        produto.setEstoque_minimo(dto.getEstoqueMinimo());&#10;        // CORRIGIDO: garantir que estoque_maximo nunca seja null&#10;        produto.setEstoque_maximo(dto.getEstoqueMaximo() != null ? dto.getEstoqueMaximo() : 1000);&#10;        produto.setPreco_custo(dto.getPrecoCusto());&#10;        produto.setStatus(Produto.StatusProduto.valueOf(dto.getStatus()));&#10;        produto.setCodigo_barras(dto.getCodigoBarras());&#10;&#10;        System.out.println(&quot;Produto antes de enviar para service:&quot;);&#10;        System.out.println(&quot;preco_venda: &quot; + produto.getPreco_venda());&#10;        System.out.println(&quot;estoque: &quot; + produto.getEstoque());&#10;        System.out.println(&quot;estoque_maximo: &quot; + produto.getEstoque_maximo());&#10;        System.out.println(&quot;===============================&quot;);&#10;&#10;        Produto produtoAtualizado = produtoService.atualizarProduto(produto);&#10;        return ResponseEntity.ok(produtoAtualizado);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deletarProduto(@PathVariable Long id) {&#10;        produtoService.deletarProduto(id);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sigma/src/main/java/com/project/sigma/model/ClienteFisica.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sigma/src/main/java/com/project/sigma/model/ClienteFisica.java" />
              <option name="originalContent" value="package com.project.sigma.model;&#10;&#10;import lombok.Data;&#10;&#10;import java.time.LocalDate;&#10;&#10;@AllArgsConstructor&#10;public class ClienteFisica {&#10;    @Column(name = &quot;id_pessoa&quot;)&#10;    private Long idPessoa;&#10;&#10;    @OneToOne&#10;    @MapsId&#10;    @JoinColumn(name = &quot;id_pessoa&quot;)&#10;    private Long id_pessoa;&#10;" />
              <option name="updatedContent" value="package com.project.sigma.model;&#13;&#10;&#13;&#10;import lombok.AllArgsConstructor;&#13;&#10;import lombok.Data;&#13;&#10;import lombok.NoArgsConstructor;&#13;&#10;&#13;&#10;import java.time.LocalDate;&#13;&#10;&#13;&#10;@Data&#13;&#10;@NoArgsConstructor&#13;&#10;@AllArgsConstructor&#13;&#10;public class ClienteFisico {&#13;&#10;    private Long id_pessoa;&#13;&#10;    private String cpf;&#13;&#10;    private LocalDate data_nascimento;&#13;&#10;    &#13;&#10;    // Not stored in DB, populated when needed&#13;&#10;    private Cliente cliente;&#13;&#10;    &#13;&#10;    public ClienteFisico(Long id_pessoa, String cpf, LocalDate data_nascimento) {&#13;&#10;        this.id_pessoa = id_pessoa;&#13;&#10;        this.cpf = cpf;&#13;&#10;        this.data_nascimento = data_nascimento;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sigma/src/main/java/com/project/sigma/repository/ClienteFisicaRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sigma/src/main/java/com/project/sigma/repository/ClienteFisicaRepository.java" />
              <option name="updatedContent" value="package com.project.sigma.repository;&#10;&#10;import com.project.sigma.model.ClienteFisica;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface ClienteFisicaRepository extends JpaRepository&lt;ClienteFisica, Long&gt; {&#10;    &#10;    Optional&lt;ClienteFisica&gt; findByCpf(String cpf);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>